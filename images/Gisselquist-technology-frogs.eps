%!PS-Adobe-2.0 EPSF-2.0
%%Creator: dvips(k) 5.993 Copyright 2013 Radical Eye Software
%%Title: splash.dvi
%%CreationDate: Mon Feb  8 19:56:24 2016
%%BoundingBox: 152 567 401 664
%%DocumentFonts: NimbusRomNo9L-Regu NimbusRomNo9L-ReguItal
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -q splash.dvi -E -o splash.eps
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2016.02.08:1956
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 856 2013-12-09 10:34:40Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.21, 2013/11/28
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 801 2013-07-09 18:10:41Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.04, 2011/10/21
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: NimbusRomNo9L-ReguItal
%!PS-AdobeFont-1.0: NimbusRomNo9L-ReguItal 1.05
%%CreationDate: Wed Dec 22 1999
% Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development
% (URW)++,Copyright 1999 by (URW)++ Design & Development
% See the file COPYING (GNU General Public License) for license conditions.
% As a special exception, permission is granted to include this font
% program in a Postscript or PDF file that consists of a document that
% contains text to be displayed or printed using this font, regardless
% of the conditions or license applying to the document itself.
12 dict begin
/FontInfo 10 dict dup begin
/version (1.05) readonly def
/Notice ((URW)++,Copyright 1999 by (URW)++ Design & Development. See the file COPYING (GNU General Public License) for license conditions. As a special exception, permission is granted to include this font program in a Postscript or PDF file that consists of a document that contains text to be displayed or printed using this font, regardless of the conditions or license applying to the document itself.) readonly def
/Copyright (Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development) readonly def
/FullName (Nimbus Roman No9 L Regular Italic) readonly def
/FamilyName (Nimbus Roman No9 L) readonly def
/Weight (Regular) readonly def
/ItalicAngle -15.5 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /NimbusRomNo9L-ReguItal def
/PaintType 0 def
/WMode 0 def
/FontBBox {-169 -270 1010 924} readonly def
/FontType 1 def
/FontMatrix [0.001 0.0 0.0 0.001 0.0 0.0] readonly def
/Encoding StandardEncoding def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC2C03103C68570A7B354A4A280AE
6FBF7F9888E039AB60FCAF852EB4CE3AFEB979D5EA70FDE44A2AE5C8C0166C27
BF9665EEA11C7D2329C1A211DD26BB372BE5822F5EA70D99EB578C7BEFD44CDF
045A363056E5E1CC51525EA6FC061DCEBB337208EFF729802376A2801424F670
0E7E6397B28F15BC10B40012B0A3EAEB2693E8F7F627C4C9C7C6C5BFF105C1E4
1B2B9E8F09253B76040D268B80719E1B3F5A55AB7B8E134D4CB5ABCED39AC635
DA001E9934C198A7F9B9ED0028A85E9AE00421DFD8EAA3BB3B4B4CE45D209303
237BD51809FE4D880900B1EEB236ACA87B9FF6EBE6B994A60AF5D67CCC42BD56
77295C346EB4C62BDC1EF22EE07DAAD928DFB73455F091F32408ED6430B97417
683AF27A03718A156E3F6E7B6E4F2E8177503CD82DDBF4557A3CCFF4C858AE7A
F7EFED6CC521A28342436B953E4650B5792BE85EA2F989EB6D986905A61FA38B
96E1BBC830B74469150FB0B598A794FD80D10870084A877273A9502C3456E5EF
74350E6E3BE5863E8BA185EB59FB87B36566AF71200B6ED389D1287D4E925E33
B2383ED05D87D48586E698FBC5D562ED9D8A09EC3EAA1B1F300224AF20C23F26
A2EADC74562571DA84B3914D1D80B127C6FF4706C7046BBB372A0013E0AB94F0
C27946583871D272BF4F20FA84E89D745DE7BBA885CC09BA72E0F530ED4EF7D1
864B3C67007ED98800284235372F0A70C912E21E851AFBF812165B8DF912CD1A
013E271F0B347967876C68AE4C4107EF8AD1F170916210034C66394A9D971B68
FBFC1131E37FC178EB97C1B2A0F573ADD9D7C0BF944E6529734DF8A7EF54485B
A3375CC30E9E328943733CBD352BC15B06C85BFB4A96994291C72A0EAE84FB01
0F1B24D0125FB8C16D60561DF8BB7AA7DDFE9549AFB70C1E89424214609FDE41
9A142892E30F02754FD234CEB3C59A2A04C06BAB7AE40E8FDEC50559B8347684
391C750987802D5452C47C1E0B5F222DE9A0EEAFEE19D796FF375A1E1EF0AEED
1BCAC4F485FCAEE18AEC585D1A9D80F41871DDA45FEF1EAE82C5893118987BEB
4D9E345C27C7419FE65E4853B40537D822E34FF1E0BD2819D21EF607981259E8
9F1040A2D708D7463858AA5381759AC49DF4DDDEB209A278FE60BD2508ACA0F4
6A249A05B652E4C7BF1B676943CDC463B1A9D89AD6CDCC3AF0AC533EB8FE602E
0ED9A6A38BB39CA02AB042CB4A5ED28E14F40BB90EE90FA42E15294545410062
3F8A7C29ADFB6E56C72C1511EEEA10313761812BF840E5A3CFDDA5A71F0DE135
2BECD0541AC711EC68B531947CB303C5E516F18F71F3E1BF0B7E35DEF1B2320F
6AD8E6CFB0D2666679C13A65E1D6872B193118ACB750D98062B2D28844E50E7E
44723EB4243C082BC703ED67F8956F3C757799D61A801701C6C457B2B4B6AD53
D22C67800381C5E71D4CA126D7D8F56E7F4C814DF759C9620BB20BE364F99869
839FD8E30152DD5AF9200F8AC8B8FA39413858E8AAD34935A0CD72D2269D74A4
ABCBDDE3DD98EAB24D3706DBFCD5E9907E38EB02257D7F32DDC1190AF61B74EF
3D7FF335AD00BDF147756C177D2FFFAA8396C2033EF6795B119EC6803BD53A88
82D82929177263931EBFC92F57789B62A14E6495133A1B3B110F97D9D1784A32
3AA0A83115E8AED878484FAD3448F4BBFCD659C4DC4F14DEA17736D0535B8B84
820471CAA34AD33367FC9C322336A2B09FF81FCFFF0C08B845AB92F0C60111F8
6B65BB10B62593DEA56DBFF08DF61B80CF1C294C865573C3D6A9EF2F67818486
5BC49CDF6F54B543754690AD1AC793BD28FCA5B8642474DCDFC2D7048445073E
79C2A7927C468EAA3947DD453FE88C13A7180D80EC88EBC3CBB32CD8BF51D6E3
8CB457C3AC88012C30026AB518D1BE399DB38FCEF12C4E988752ACC51E817B83
9CC44AADE6DFC1BC7CD3BC95E755B0C177D8E14AED4F06B3F1FB4AB16280601D
4308FB33E7A35FFE7179D2096AE48F387E2523C39EDAF5CD7F087557E99C50B7
8FAC6A62D7CE3CED36060BBA2543B88005F4C0C7A0C8632D335E169B0EF7A62D
E9A66C3265E647DC066E3BCDEFE3928BAA8452E64FE2DAD4DAAF0301E4D98723
B5A14A5EE325D1C4CA5023439ECE5E33FAEB94966600A8B720DC21DE0755EEE6
F50ABBF988C8AF7468EB28FD5E0CBDF9E23D1FF320EBF1997A946D805BC78580
A7EF7997467C254D74D5092242226DE34650381E96D9477ED1CB332A3DB42F31
7831E6F2E7D41FAA5D19294AD7623E060977AB9233338862CD236543FD33F885
D1054A54F70EDB1BC66DBC4A59C7EB9F062ABB34EB073598F17484D20A23816F
69D9CC4B007EC9B5F8E0E2CDDCEE93246DC5D6C0E5FC68C7109103FBDF1B4DA7
CE2B7194624D33B42527A0E775A78A90EA9F52ABFD70788A26EBE7BA4D5421A4
D1CC038F36DA35508230C17ED91B4301306AE074B4A26DA8E3DC78A53161CB13
8755E22134765C432D1CD4221AD435CB3AA2B2F202B2ACB0AB17D622FA11DBA0
F3234DCD435A4FCD5047A2EE5079CA81F05ACDA9021B8E366D8D228A61A9CAEC
03F70A7C354FB0C308698BD5C2EC59FC8128E252C916FA973DFBDB8801BAC3BE
E13C9779C556CF38BE04D0E5F5A48C557882354B6A570693274486DBF2B69224
D2758B6C88FD72169FF1E6A2CE0DE24FCF5C091A71A88BA2CD60D97715676AE2
03713C525D6B12C8BC41BF641A35D16CD267DE51CCAE6ED037138B3294CD515D
B323465DEA95A929C4915094EDB97DF199549D54852AA8217E48B2B0BAB53E3B
40238E69EE9BCEFC8182D5BD8BC68D51BD2D79E1E9086591EE5680B98E72A533
3860A8AA45EFF92B89C244DCF089676CF6AF896A75678AB421B33A4C465545FF
EB9BE81630C673E4900ACD628933083F0AFC3764AF5AA364DDE7579E59AB8F63
B4E0D1C4D5047974175E6FD7D43D9134ABD970E524EFAD438A22F578C96F3365
51A6836C0430A946C0D864190CE11362E388B8AE2BEA81F9C2737FFEAD2689AE
E3E930BEFF478200A8847CEAAD3690C5D73FC232347B4A3852F42A06A1FFA362
AD33E97A907B13ED4B7D58A450EB9F03EC018F284F746EBCFA56734DDC425136
AB0EC68284C8F5E19646935341BD381BCC0919429B21C62F2B7F4146A4DFAA15
7D2569CF91936714A6AEE5697501FA117F3C37EB7A043E36E6AB180447696236
67C89B05A2CE9509756DBE4BADE6118F4DA07346171F817A47D0940F8B3BB3E8
C7295B779748273C485A5F88DC1C0B72207FAF08E24C5D0A20A385910CF5CC95
90B7D360453EF5FD69A927D3CAB6302291F8529F89FDAA146EC005D137B33049
5803061FE191A6827ADB20E619935816E253B6A3340367572EC40D3E1B933BAB
CDAD9841B3D7DE95307257BA246EDC7D497741961B03D889A8BE251892211F2C
244EF9CB3C631E3B8EC150E294DA02F9F2165878537CE25C6B60E8DB80ABC3B5
7AD58F442CF083852F768876B706BA8D645DFF31FD311551CF6300114294C3B6
D97FF4AC6F782E099E802FA5F04ADED34F24715686C4B136084BF088D831B615
1B8368C877311315718B6C5CA0BB3AE292DAF45C81753790D37D873AD0EFD2E9
B62FC0811B53258B5E638FF1D72EF064471AD413C489B0062F44BA8E1C15B33C
F155AEB9151499BC7B2F889C9F9420927FBE61E2E6D4B23E9BD331F03E0F3766
8F77C77D1C1E18515F5CC3BB29A57B7DBE0D853B0FA15A4D58DEF4812FDF9458
012EC1A61ED8CB928BA33D61D0F17C1E7D2A1403C4ACB7DFD87875B4E4C86CF7
62C86B7913519AFBB9B91CB420838BA0919DEF1D3F443A32A724A003C23DE44D
0A16405D187AB30CE153914AF924F674813266AF9200C89111A8912FC701E722
D7FA3E8802243901F1E0386C13139FAF321A2AF2256EA0675264922F9A98E6FB
C0F56F7CFD366BF9B140E1940E13D7443EFCEED61613AF5764195295C87793D5
F78FF22EDE240535D6E3DC24FFEEB4C75EB7B3A707A6D447DAEFB6250ABAC16A
5C8D36CD1DCE4AB6E7671F4276E6CBC2A4EBA4E6A9725D4EF9391026D75CE7A1
1CA281E861BB0E2F6D9B681D827E3DA29A3A4117DDEEF5925608991F06827D0C
88F2A4C93CF8428248DD241C3C1A2DB4C7155F82CDAB5CFD9F86253ADB37FA87
4126F2328BB5C8627471B7320CCAD9722595E7497392C3C46C5FC40BB41EB7E4
91B583EAE3970CAAD43A517140D3FF737F4B3CC02A6B660EED262A263D11F3C1
CD643320EE99E2C27DE59DBA46B98DBA2B2A765071E4A16AAEFD449691315367
2F37126A4344A18554F7D00FD38081FC165E7EB0554B84B850FDD4A4825D4B77
C9B0F5BC8803C5A0BC1B870E3B49106D255075CF360677F001169E7ABEAFC85F
5FD463E2B69CE5B35A07D4F59D56FE6359BC8EA4C1DEF06FD36679106A755F66
3D97F370141456A5DA72442BDC46D862F6C42274D7CDCB0EFE22E31292C3C35D
79F9289601D57E27D730EA39BC8396874506B7D2BF7DF3EBA27244E64A061404
27CC6BDE166ACEEC8C9F63BF23EB2C418D8DA612E7D275AA4EE5B6493B7A5CD7
B1BB36A193FA10E93D48189AAFAD5289F9B5E659E88FFA971BF1A0AB4B2A36FA
46AA5CBD3DD8C1CD5E3E5B2E3195AF5222BF2C1E84E6AF01D8B9FAEEEC938C37
D3AFC03714BBFF19A4F66E72C1F50D22B1CA7D89EE3490872EFF39CA0EA66E4E
4B862C2439382366E8A244F5AF3DF712D8A951035DADCBBFF944D0E752B95B29
D6A92B94CD3F42A873DAD84B5C9DF0186C8CB9E1511444CCEF81F684733A79A7
3B0AE1EF9453C76079573A76E4C5EA7DF821E8B64F9E81353C75C8515E9FB2A5
3E489D99F833D72AE088F54DC0BDD441EA5EB5A1FB8DD19C9DC828D856E1923E
8FDE1C1AAEEAAEAD61D759A55AD7C34EB4CFB80203F1F479960DFDE8DAE15A57
4DE45CCD5C442D0BAC43A62DE7FC6144F1BEAB18ECB58B54F8DDC7A250D957DA
BBDA95A149797072F2714E9747412728C26D0785C7B52C4EEB470A7B6CA50058
E424E6FD6278959EE41617099AD9AD5D599A7703EAC3383DC10420E8BAEA84D7
B160C9596D3FBE16E63FC86EDC9CDEEDE3F8A838DE00C272D7BA3D029B395680
F37982E972879063567FF128582D8C939362D7875D00CE9E2DCC82D42B3D2A6A
13392EFF721B6AA9342A44D3151959D4248645D9EC451A3638833A69C6155CA6
0DA77EA9AC90E5F582D6EA245001A4DA0FDA9CB560A111F9E00BEA89BDD20F5B
A0B42F31BA35665A2BFFC5825C1116B3F0C9DFF586FD0F1078D9001CBE6664EA
5F79C6702E25B23EF5960F14695FB901A21081553D6E4C6384824DEF006BE426
4F2DC7C4084B217659B9E52A410904EC5549D32F6316D48BDCB0EEE5B2773511
66752247DBE0C51AB36B1E6B3341ABCA05E57D7B09574D1FCDC39C9071280227
15B2D50383E563B8D56E7AC33479082D25F2104922CC21BD921B70419945D68F
5EAD5F51549CF764B1903E3846919D56B4681AA3031BEAF016845F0AB0AD4978
9380E1912E88FEE203F86658192FA198348A5849507B6949BCDB9DFC54F02FC1
B0600791191AE0D249773A2A6A84C297C6081BB1F3246542410F3D8A4175AC6B
E1B34565C8D7DF2FF462FCF8E583B4206845D1CE10E4605392FBE8772AB6079B
DE73FD9BA0C58A93E39B057163A1FC431917B745066FA35B05E5EE81E1023431
CFCF64F1E1869605A5E4D640609427A0ADA6B5C7D12DD26C0C60DA74F92B1A79
C9C70901C10F5F96D468BD28D6A2FE2A410DA6664840833B20B4A667638DA67E
650EB7B1DBD7D59C6DF936C05D5E975147928F693BBA9F931A9931C8CF43111E
83C0424B11FD8919E44E43AFCDA4DEB5D18C99062F9DC23BD17AAE38D52AD6A2
2768AC82C7B988BE11A8FAF6C604360FCB236B33EA26B4246FD46F6DAD77563C
1CAC81F53736A4F2D8A1E431C09DA9A47BE599F8B798BF1BF82BACA78C35E2C5
481C54C09FA306EA93E3E39B24190C58B67AA9CA8FB9A6292B39B180540EC038
37E34219F43D57E16E2FA941005A59B39CDCA950BAC8040D6AA7C7E963CDDD33
23603C64EF43D3694394F4943992C214CAB6F17CE79BAC86344C9D126EDB6E26
05D3798CA0258C0EBE87933ED4D842F417265427E0F2577E990BE207CCB5FB40
07BEF138FB743C84B1881C1BF28DF597C266934B7B24AAD00FD85B12C2676AF0
A06511DF6B55D89F3905306EF28037514186684C39C3C9C4F1CC23A16A458410
9FF76F36E486ECE5606ABD7B7BA4FF9B734AF090B59CF8F8D6DDDE93F0C34FFA
98A56595B7402C05234CB3CD343344C9019E8538016F8BA6AD48D9315E57C51F
4C969C464C1CB1712283C42A77AE7874B9725B3049701ACE4F6E8D02D1B86F6F
B8429E2CEF1DE3B802B8F4EC0574543D4AA0D04B149463928A9BFB43173E61A3
6005E192EFEDE759A326A9696CFB3A0C9B5E61962ECD72667657EEA9150CED1D
DBBD4B12F2C63681C136C1202857506886EE50C0E5EE417CC93E76B4822710DF
76E65E160758BA0E384E538ED8FE0386B9CFCF36F5D2F3B3E1BBF6C6DBCEAC0E
29609A3FD25937487857C43D2EC67386B5FDFFD4B396724448C27711E2CAAD65
3F199BD875EF9720A41064C257D7E2C247F96F290BB20178DA4F0524D9F0C600
43D68962B53431397C53340F7D6FCDD75602D5768DF17BAD71BD8F24699F209B
99D8C994CEA95428844AD4E4A3C5EDDEE8341302C8DA5DD33DA0B3D52D76D902
D0A361FA62DFB90DA95B5899C975CCC0039C60018B84323336C19FC07CFFCD39
F92BCB71E8A2E5272FE67DEE035EF7522B4AD8AA2926AA6810D364B8913034B3
FF29BA28CC460781F1805DE8EE9CD7D9AB93F1A4B84515D2DEB51F7FE1B12BB9
76ED84F8E3D653025B36C00DE52DDD1DB6C9C7F60D2895E2123206A64224D529
092E183E12A75446B0214945D1BE181BAB616D0880FB22D0D6BFED635AF855B1
62A919B8D0008D7ABC1BB03E9175E2F6B786F0EFEE0B51371EFF42B481DA06FB
A3B6CB864F5099DC8F7DC87CDBEBDF508F3EAD9A57AB12A9A916D7EB1B0EBCB7
43ACA55A619FFE0DC4798C4A051C0097C96BB000DC86F1A0BDC84BD9EA252473
2873D39D2E8ABC05643DA5F9D1A233505885886A1FF6EAC0D3F5657C94C8E134
3930C113718B34E1640D5EEA6932A5F033C432F68EC3C28C4E129DA8CD68038E
A22C0BA93D42E3508E57419B71CEA4AD0DC51A69C966FF5633189679D19FA46E
E94CC0109756F0D837C4C65F756F4E57E1774D0DC940B7A5B0CF6EB23BC007F5
312617A39307CCE2C1B99B8FF8D5F1651E70F35D9809BF13109D02889907B23F
00D4F6A0D9B74E591BADA348B8289843CB0B9D921B4A6980F6B22FE3C7B7CF63
57CCABF93AB19D0EFE83937474321B7E4C63295997DD487BC4B445B0838500B2
84B3CA2F0D601802F984D0565C0105CC05B6BA139A251BCF348F2A19EDEBB709
068CE066955E326709CF1783C386AC2358F315677479DB92989DF9FDE2744E56
631FEB5BEDACD00C64C344DC67A6461977D718B18BEF7A4D2DADA9C2961A75BF
513FCCD45751A59DA15DA1F237DBE7E9E01F3713A969BB9DFE862B2AD2547118
B2B8DE41915E54DF679F12079DF942D87F704B8C183272E4B12630C2651431B3
554ACC5D07ACEA1E0F8008F669BD531EBD40F60C2966E53B67F590AD3EA1E18F
E322A7C55F1E6927BD33DCB19F6D34A59C86F0561CD6D6536C922E5D54C8528E
8A4BEB8FAB9005788A5B0183E08ED9CAF70948A4492B9886712F81E03850B816
E8AE1B683FE6FEB1DB4D034DB5A047B8D574769188C0653F8C3529BC281516BD
1A6C353C9BDE6BCBBFDF172866474EE77188271A42DE0CD89406E432FD56FEF1
21AFDD14F8766596D923DE6A4819F3DDB1411C376787DCCC4197E6411874BCEA
002D2EF289BF18C8EBAE755857D51C8B7F34B08DEA1708E447E0C557FAD8D550
A1F61EDF75950D952D10AE95CBAAB2029D54B3548653CF8009E776AC4B03E6A8
E7449093FDB99991507C71753EE604A02B59109C2F36F92CB169B0F5A9A943C3
9CFE18B2F8F924589B3245AFA24A920699BB1897AB7BDEC118119B191FD7B864
8E8A33B7ADDA86A3104E70A9BEC87C27235846844679E058655C4D974E2C81FD
6C66A62BE5B99CCC94A4CDB63C9E1D0BD725BBFE5A62D500FC13C0C684F84701
4BB62672A22BAF1F6A8D058CEB08DBC89F2FC918DFFF937426EB3FD2020938E0
2C1838943198A9E3DC207C637F63A105C17FF2F9DB2C13C2A491452525C32CF7
ABE913472076A87C23C77BAC71936A845A6921D54B1A7A532CCE15059B00188B
3365AA06FC76C8DBAD9C603962D53EC89031FFABEEA012D06578549F73641EA0
59331AF01704ED01EFE2B853747CA658126FB4ED302F86E3AE0070934F91ABC1
B08FC3781405C233BD19F3DDC5ED831A553643C9AC36A4D6E8EDC328DFB86D2C
93133D33B86022C15275D14ECA82E2B38013DB8006F9C75C9A358DAFEDE791BC
9CEDC79C08DA866D880513141E5C738478864C3A83614C9D9D9AA37D7AC0F908
92904B92926740BA2B7968FFAD05B9F8DACFD91EB7A68C759D267CB55D49BA87
056F6F701069C7BDFA1A6F3778059699529B4CB35CEA0B1900ABCD54D8498AC6
D01DF73C5AEB8BDEE6322F5C6201F1EBC619BE50F1F40C905809E135292CDE4D
9724E51225BE46D06A3E10F2677C88F38164D2E36193690A03EC721F45406667
C486B4968DADD7B32D26FC4E8CA48E79FE166C833E19CC515F9766ABB8772CA3
9671C9625C1A4ACBB96F952F6FD60A7386846C94005019D1C6F16892E12BA1CC
DE83F89E594BE294FC2EA48A1DA1AEF10C5AFE819E3A60012764F1E79BBF943A
2BFDED1C6EA2CFABF3790925569B97E9BECA958F0B54AD42D4B42A6278CB4E65
7EF75E5FCB616B45530B4D8DA96593F380CC97615F4F9A8DEC80354AA1195117
8C38D85BC1D9FBD918A9F5E54AC7C629AAFB49C3247711B2B37A0BB599F8CEA0
91F14E30C305877AF2D4CDAABCFAA0084A60CE8029853BC9D1D4A53CDC1357DD
3BF819C0A482398203DCBA76E49BADD94B0CB3C20C3BDE8F3702EFBF0718304F
BAC09C37DB5B79B72B8341A5E6E87E65A36795B24B4BCB9ADA1EC4D106A8A4F4
3FC2DBA4C2F3BE08BDD7FED053CAAD0863D5E8D7EDE8EDF66B6B73DC48A70D01
81AE62EAA9BAA645F7603D747850411CDFC125568237B54FCBB2444A69994113
5F94C270503E37E6091D0B9814C63B5D7CCAF671A1095F1C3F557F5262AB52E5
46CC23A0569FE50A3ACAD9F57A23816AE5221F78E51AE074299CF7266E40B3CC
11B3F2FA71D5981909AF93AA2613A64EA8FE427A8B6067856C3C77B575F661E8
BEB7CA6FE639A7AD559C8969B8C5B0D537406A476551779DAFE15FEEB5531B22
7A387941B6D03B22EB0CC595331AFB66ABCA7528E45F3A3BCF7CB90F420209A2
ED5CD0B727EC804947E855A16F117548681C1EF50BFCB1BF9C97B4F585FAC00B
B53DC0404C6DCE463CF00F3F81B0C94B2F88E81CE557AE5A3CAF2F4A89EC34AB
10BC2C9874A1B794907C3FC0A983134EA396238D31C1D3427BDEC49C70E9B7A5
8322E4A7C3A3F8BEB2B3AF408DDD4A23828A8CC7F7910467D9C7563A685EC6D4
B6AD5E5609DCA3FB1A0673959E648B002CB58409F2DFE5A2F4912D5FB3A70710
A7BB990BC23818F1623CA945A3447AD12D5FEFC045DA4EC8A6C286DE6F15A56B
3D790A08B2B505A8E901D91902117915A5BAB5A434BB01C1276A9C7D9E1CFB72
5320D05813A8F63F111E9E6E1DAEE29FB8965D0C2EF4EC0C191AC5FCAA0ED19F
57292A6E945AC9D0F56E06077D4C2D61211137302A191445216C26286A14C923
69722547A9137CC51A2F14A9F49E930362398734E6977C4C730F2A379836B655
2A9CE788354A5C55B845869D1E1AD8C6540161F45A804CC29B338A5E1BC1E7F5
F4C986A3CC2AE02B20D1B1662ECCB2CECDC4EFFBFA7E59858A7D76FD4DD0D4D7
FB381FEA4AC1CB6FE29FA5B881B3980BCC9658D0D01C6BFF67E70870FECAF662
CE012946FD3A47BBB4CD41E6440B1CC513A82CF3EF64B2FD83C2F2D78B0398B6
13E9A4C5D8B7627B19A8AF4A0666116AC4A57734BDB9568B4CC981EC661F6142
C6085703D3C70ACA3396BB2521AACED6A6FB41CCACB2011DFC2A8F6D363B2BFA
3CC934A14CDF4EA70E333099120395FEC8C41783CF076B89B7B2D60AE9A2587D
40B8B7095D97596B7CD8AA8286DC9A95710B06B17A8ED4BF3246E81A67ABF03F
479EC9C383D63F9815ED07AAA7DD5E0E4223504CBEE921F823417F62BB1BA4E3
708CB8D0FD5E1FEEDC5FCEB4A951989ED0F182D808DFC0842A6E7E6903768E6B
5DC6D4761B9FF0452CBEF249CE14D574E79A4C66714A79A9DAAA22431879C119
FE6F759F143742D69F104E46265119E6648260C7A21E6A49C24C33E03FDDE0FD
F3B0A47F027DCC30F1FDAF9EAC2D7E49A90F05AF8195CD52C5190F2AC6738809
1431E2B13F23448409C6246537617F3717D7BDD839C09B996816AF5B0D9AF771
8ED0E299178F37227D4F1BA9F317A2926BFD3EEDA261FD78A6024F3D03EE6315
B81CCBD288E6D0CCBB7F572E469CAA1CDD6E08B8CA634249A08751EE41159023
4A6DBFC0
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: NimbusRomNo9L-Regu
%!PS-AdobeFont-1.0: NimbusRomNo9L-Regu 1.05
%%CreationDate: Wed Dec 22 1999
% Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development
% (URW)++,Copyright 1999 by (URW)++ Design & Development
% See the file COPYING (GNU General Public License) for license conditions.
% As a special exception, permission is granted to include this font
% program in a Postscript or PDF file that consists of a document that
% contains text to be displayed or printed using this font, regardless
% of the conditions or license applying to the document itself.
12 dict begin
/FontInfo 10 dict dup begin
/version (1.05) readonly def
/Notice ((URW)++,Copyright 1999 by (URW)++ Design & Development. See the file COPYING (GNU General Public License) for license conditions. As a special exception, permission is granted to include this font program in a Postscript or PDF file that consists of a document that contains text to be displayed or printed using this font, regardless of the conditions or license applying to the document itself.) readonly def
/Copyright (Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development) readonly def
/FullName (Nimbus Roman No9 L Regular) readonly def
/FamilyName (Nimbus Roman No9 L) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0.0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /NimbusRomNo9L-Regu def
/PaintType 0 def
/WMode 0 def
/FontBBox {-168 -281 1000 924} readonly def
/FontType 1 def
/FontMatrix [0.001 0.0 0.0 0.001 0.0 0.0] readonly def
/Encoding StandardEncoding def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC2C03103C68570A7B354A4A280AE
6FBF7F9888E039AB60FCAF852EB4CE3AFEB979D5EA70FDE44A2AE5C8C0166C27
BF9665EEA11C7D2329C1A211DD26BB372BE5822F5EA70D99EB578C7BEFD44CDF
045A363056E5E1CC51525EA6FC061DCEBB337208EFF729802376A2801424F670
0E7E6397B28F15BC10B40012B0A3EAEB2693E8F7F627C4C9C7C6C5BFF105C1E4
1B2B9E8F09253B76040D268B80719E1B3F5A55AB7B8E152A40E590419249F2E4
C36159F8E54B532468E36965A38646781AB0B7F6A3E851FD10CAA49ADFC1E546
2FD2EC6150DC6E19523050F6148348A561AD8D2E2721EFF8A570CB33460A745B
926C889304C09753C2D78FB0CA95DC6DE5B8C524752C83601E7E9F73DF660674
F05AD83A166DA9BE89F22FEABD4B2665960F6FB5BC32928E1230C212E5D69CEE
0B3311A1738A11747AE263106916D8E95F25B25B4BC6AFB03B79ABB95DDA518B
41A49458111D2A1433C043627EF9460D324FFE22935F4F6DA88B8B91AE95B34E
08408A34EC8EAC3F65B6AE3E3E2524867EE9D29068F81E4372F4470BEEB4D6BE
EE4DF956BECC0CB77F8490117B22B2FB75C938ED0A5E208D88BC38B2AB8B9CFB
F1D53084B6F43DF336481ECA0AA2D5317BC83FC0E1D4DB01D0B7707EEF217E94
A7F985102DED27D8E8B009F7EF6DB91B91E78BFAE7BD688E10B3DC9AC77CDEE8
47AA4DC8EC78241E593D26EC7A60696151A2AE5325D736E99E01BDCBDE69579F
92EEEC224B6757EEDC64A75455BB665DF42A0E4CE7B99BF3E7D66F8FFC8C13F9
D7A1FF7A9D5FF7AC43396779F11C9B008C33A2043D48B61B88B03104B1425F09
675B559CA4302C001EE80D2B739CC0FD1023BF4F1FF9C01E892E59CCA7C26011
B8E0B6D29CC29FC72792FDA5E7D5D88EF98F9DBA960C96534C399C54865EAB86
0FA2E0D6C7C44B553EAC1574D55E7970744D4792FFFBDCE6FB4365BDBC2965BB
2E9EDAD9E0EBF0B620DB415AD98297F5AE83D9C710436657E74D26E83957C745
89834337035A7501803947F6880B70E56A3A404C62D57B849D28804CBE0F5884
435A0E12DCC9BA414ABB732BFBAE237001F557DEA5E972BA0838A3C7C9EB75AA
4A050DA0A529BDFFBF9011C360564FD17A02C18860AF6B86EFD4E2C125686C9A
5E114E95C71FC89A5DE9C589BFE5AC0480CFF716345265D2435EDAE67CFC4801
5BC08E7A48D683ACDB91E05F469C0C8919D73A5D07A1CCB173E30E76680ACB09
02A40A3E11916198BD69F1A26E88330F50692D0D5917E99E7A01B327413E24AA
E98EA484E45897E6AE4D6997B6E8BBF61C9406E916D56985CB2BD297E8ACFC6E
CF2D2281AD84696B7C6CB584BD85CC20BA14ADD3BC3E25DB91124C0ACF22E902
3CFBF04CC40DE331991E9075D22AB5EE0E849B340050E6C417C664A782D05549
DB2EF572F193B1C12B4635C2B358747046DE585E9EEC4FBBE9CE6AE8532B2CD4
101F1E68B19CC8756AD1987CCFF2302525BA8389489E8AD29C974C5A18DA8F05
5671EBB8954C3A90EE42B2AFCC9D2F52165A0DF06D6A365FB88544455AA87281
8C323EC616CEC04738328542CDE8B0B5BF7C93F1B7E133F3A0518EF8DE086451
3345AE867EC3032919647C526C614C58D6AD7668D50EB5705B5F8F86CAB5CA38
79405DF665D0513A29CA1598EF607BE11D603F92B2607D41C3029037A543ABB1
E059247E276E206CB00BED125C8F78AFBEEF8A8EFCC84F58309D656041D58C14
FD6E83D26D13AAE036CEFAB476721A2E3A65C2C5B0C7A8CDA3DC3F8F945E8803
662299C3FE983D7D85435A622644609E4A0E2A68646E9583B6B9A75C95840BAB
3FE1A886815826A0132FCFD809E2BC34AED85936859171FC5B2E0903AF6D630D
C6F2532EFBA61D0CE72227D516759EE22D9F51DAEDF5873816653E5215E436CF
C0C888385900D08491DFB085E6A13EE6C92B0797073BE1D91564F0AC54D70F8E
FC63B94F73ACBB4CD279716D9F482833B69725F53363FA3896798939057C6223
02818F0F735BA0468954522498086CCE1E87A9435170ABB7B721D7440302D3F5
0A273DF58E4C5280F43D4DF87E5C4DC3E857BACF340CFA7BC22E210F87DF1099
6FB54B98B8FB2B09B7F5A4D013A42092913C1B2635840881AEAA0D7BCF7B8B03
5A2F86B132AD079E3C0C9EBA174022ED2EE21A5B950485E2D62CCF1A1E277D8A
BFF556029CFD2D1E54F05BA49751FF706500F8CB45D20FE0897E2907ADE65E8A
F53AD8B166DDD1069C89BF40433C1A7761EB74BBCDD0EF503B3C0A7B6110AADB
0EDFF36F24255DAFB221C113F8E414A15E2E72E76448B6CE2AAB25ADB6B6B2AF
F57F0B294DF7D539E4754CD2C62F1790F8A442D94ED07F5F983E6AE6478E9BE3
326266B2D53D8C44BF4406642BE1AE8EDEC76BCF3CF60BDC1DB09467179704B9
F04B677B574559D47C3240B0D4A30A382DED5AF585C938A80207557EE7668528
DB216195143E8CF31C5D103CA1E0B0092B0CBD2223900A5A4D8EA5A116993652
2382A3D7C2180C19791C85A0DDD1DFA04D362503CB2528CEE5CE3F7250608058
EF90ACC54A90659DD7AF69B2FFF4CDA6789A50609824588E505F6A89ACA2C20F
6C0EC6F2BD8471A03D56FE7C722619CD8B47106750B3A44FDC35209300AE63A1
5A7D983219EB991B300213F0DF5E41680BC305BD5820C99133597634BEC5C690
EE7CD7C9C59099D49B734E872BE687E13CB3BC0CC34A24965E7BA6C7A435D3B7
FFC9949F0AE8A8456510B739CFE805171D6D077E6596B331BB209C051F769A45
80AC8A4D2238D08930DEABFCD883D938E95DE306F23139662C3B88CED3CE03E4
553E6C44932FF00BF462E8727EC913E11A8B2922DBDC327F4CD17E6E233BD37D
0322C3C3B41A841F71ACDF0EC3D63CDC6AFCD79623487AAF1163E21745C31D05
5B00BE865C5A8CE06301E09E125F59428C13E4D090E30886D8F1CE06E367580D
62A307C632D409DADF45FD193E6EF5F8491B730E6F350C0A04E5A4A9054DF03B
C9571FDE1A190C40A5989329AB07A6E98111D319AFF427C2FCD1B346DD76961F
450DF8D3BFA48D28BB363416C0E53912AA822C2F92F25777E7D80DC986174F23
5BC0E326D75B020D7F7EE25C212D3F8DCF41939DE5C3F2A05C77BA4BC01C8498
B0DF87DF883F9E6C05505A9AD585E3B8C70568BE5B2F77646DDB328977A2F5D9
D63862113A01515F0EFFF1B86E62BDEF2AF7EEF1D23D57E3AA78A2A89E352BD8
FFD6AD5C252370F5C453DC86E4DADFA38D16D2062B9E49E0E71C3B0A1DF26D94
562D11D29AC32F91BBD0DFB6E17EF817E0B71024C2DF579A8C1E5ABB7D455617
70BFFC22E3411E5E40FF245992A0EC3227C87D5A69DD11F6760850FD686F7980
15231BA851FFF5F4C903F54E22E2B141D5417FC4E56B370A532042D0ED661359
4454C0C98194B899CFE617259AF5BD51B089CF6B19B051C243541591BA42B073
8C360E479D5FEAEE1C2196A14A4D6F646BAFEB7C19098C9E2A56F4A3B7BC194C
7854C54411F14FE808D8D515C07A300921DCC7556834DD3F66EFC7134F543BF9
748641D4D2A131F19A7BC912EA7DAC8E354F1CEA9C76D10F53C0315B93F0F0DC
AF80757EE1EA8A78049B8A9E9989CFD21EE48F9FC2C35D851EE98AD3863A0A6C
40428E7414FB9518E318B8C06D638E02FA63A5508EC4D6F939B5F50DCAD816D5
01A60C51FB1F38771C27251A53A879BAE54B4E5F84D18147590E054B70E3F30C
BA5031C73E02B5065DDE064D64B07C5041BDB97BAB801B40FF982B41BDDD559D
900C5BA1D89304BB7F34C33AB527C657944A22B273DEAF5C865DEA06501B0FC5
37D197EF920655B93EBBAE2BBD038F21047D0019EC26A2BF7268900465D114CA
FF0FCF67585A6BCBE22DA6E90A3533028129F4A085AD9DD05C3A4D0001737F95
EF870932F6D281F0F9C45F9969A88E05652EA12974AD642A19815D7F9C36FEA6
227DA95F50169523BD5F9EC48CFA1DEED784AF774EC42B197EFC181CA0042E22
BF365D09C58E68588F97276D4996DA043D51162B7C6F1675CD4D773D43C23A97
FA95F55969869439CB07C0096BF4F9D1F6679A2EAA2E4AD47AEFF770F0B37CD4
334403C404C616BA385DF04B3BF096B274A94FCD5719F163517FB66E333E7704
BD4B435A2949159C47091A0832D4CEDA6CF08290944EB87C14221EFB3A7EA319
B4EA0EC773D5C91635154FD33D8E79B4C628C92AF3A011B67DDB6DCD3E06D971
983638408C5D99799835E47DD4F86A7FED807193757530AF7AD352563063A1A6
B764F66CE61D12F55FE997780F5BE7AEDBB1E59C200B6C19D8F511D3D325A57E
59508CC2064BFFE7C27027236C04B7C52C9D21527F91F5F20D556E956F19270A
4455D81D673B1EB735C050E3F02A9636E89EF795734A43944A72234A4AC98248
C0D58F0CE987E3D86D72358F53C5E1278B2BF406DBAC4C5F555EC96E760C8245
A1AD9F508E3AA46DAE2CF46DA6CC1D18B00177EB84A53FB40DAE103B4B133C58
D716D29E8FD7A27BB14FF676F11A42167642D8C77E55B9E967CD057C1AEB9E46
3700DEE263AB056C27A87CE961E0DDABA61649AA1E4BA123771484815AF9CD54
46664C39CE8B2584E069121F356C46446B78E89DD66F9EEEF258E53D698E3F2B
7FA849A50C5ED0923B060EA6EEA5B735D0D62E41842C07BE66C4B32685892955
71F959A0A72138889852ACE42D60DA2382708D050BC6A2263B7F797BD4F9FD0E
F0EF007F84B345CC06DBE98FE9E52BDF3CF8FEC118F0F5497F458600B1A87AE3
1E65B7EFE7B1CB025613E53C84273053365758F50534E61D650001BE80A48A2B
10D6FA6074CD669B124A8333FC4173EDC8861F004211ED42C617F6B87D60D24F
43DB65F27BBE55B994DB8C5A75F3602396A1B7C3D1906E2827AB2FD80B579D0F
E2AFF4DDD78DDA83C237AF564E874A8CC6004D0417519CE3129549C594D33B30
DE0A59DC9A63C6815361B044836480F5C02A3B5CC0FD8F5932C6DA4ACA736F05
529CD6732467BF89E8EAC7A4865824BD356EA9D0F90C497704AD5892D7F2E681
EB1EA12AE2DC994A2EA0213E0A0CBBC22A3CDE0856BD8640D2B9B1844E03A1E3
BB7167FA243BFB37AE424572A24EFC245742B43DEC68690D7804DE2809825F71
D5DD1A1A289CC9216E5318B662089EFBECCA2B2664527B384EB259A7B19DC098
B966449769ACA5771BDD5AB3A11EF1E669957559949E9365EC635C4E3E11848E
1DF93CEBD7E7369C37B876134182752B62169F867C99FA46CCA8295F61E6D47C
6112E6DB4E1A21936FECFF75F20F0AE14C6E5DC7E1BCF8EA3EE378E5DF032782
0805936E1096A3C719CC3FA528FB3EBFF12B75362F46B9B039AB8742D1F8A0C2
19CF2559CA671368513F63E46DE52CC01A232C2456EE913CABB9B2A1CEAB476D
C9BC9164CB93BFFF5C5133C354BF8C7532201DDD7B02668B23E421A9436CCB8D
7C80BAB081E9C62A661500562167C50A07390FD01FC6CE69EEDE25A0C58C9F0B
36D769267586592927BB429D9534039326416647BA91FECE6986ABBDD4EF0DF8
D274A5B7A04B57F2471D335BB9BBEF18E9E1BF3011EE34B5AC5EC8F425AB740D
EFA9582ABEF7EEBD525766E58B36C5B3BBCD772A1B9A9CB8C170DA28AC8FB7F4
3EFE13457C8DAFBD619961BE8A1DBC357905D12297196CAB02D77D20F452BE93
936D2AF9A7C99021CEFA80975D663D634D91C66E8925DEF81F6AE1290530CE2E
9777C501313A8AE571CB7DB76C1AF86C3818A86D6541C9150BDFB586383A5CF1
546572770BBA3CB09E41AB8CD211371E9DBB2C444902372C09780A27033473A6
BCEF08BE042B432EF1BF760812496B2B68D9DDE004081B033F28160DA1F80AEA
1F88493AF0D855A08DE6A1FA942A4E3E66EE62BFE3F465FE1CC6B32A028038E2
E8380E1775E91319A33AFF535230AF54B43EBFDD5289772C3DDD2FFB760E5AF4
FE10DDAB37721C94BDAB9EEA26197FA5B43AEEF885BA3F295E47D3298AA3FCF8
3E09747B51BC3545BEB91F772F45DF28989BDD48D33F914F979EB7C695747A41
B684D31B4044318CE9709A2931121BAC565E20162CFEFAD5AD6FA7F42FE1EB5D
78F64F2A34413DA594AD4A33AE62BFB18C23AF78E2A7CF129EF7EE4A49B50A67
72DDAA9D70BE93EDBB0B14895055B10E843DBAC8536CE3BDEB89E0B322E43CAF
E56C87541584B2846019287CC9C2B407A78B50FA879AD2FE472A3FEB57E35599
FAD0B8A52379F32DC8D14480849B85FCC583ED6BC743C7AB0E8AC9DF9DFCA7BF
CB7F37873249128C214C434123A76CCEEB7C0EBB5243B5EA52C15F5AEFEFFE73
2EF63E26D4ABE210875AF8B955615255A6CEF30634C7107FF91E69B602C28FAC
8A8EE3A2CAEE08C034A277570A4DF138396B71CE30942E213005E63A29D55822
5FDC0B486D2C6237110A8204C66879032569A42DF985465F2EC994FAC5C4F5BC
A653179798AADAAF4101D1D7A6EE4E5767852628A24A2FC36B01977C501B03F9
B205301FE5A2F546BEC33FCFC4AD7D38EC33889E8677AE9E164198ED77DC361D
70AC6E0064257AD66309C4B1A3B5008FF8A05922A238CDA134713DEB1CCC1064
31E6138025CD571F48B3A78907A74B1C1E3A2DDD2DA8A5CC87F883E0FFAB73EF
C0D949A5C7CAD217D4E8A904B98499E22AF12A15F01E915ABE17686AA282AA9B
11484D9D6F0101676B78F8A2BA9CDB5D3EF4672C26CFC1B352595ED325B749B9
6B135E11DE300672BEE9F496F6A0139047B060A51296B02C18AF4BA1669D0C00
93F1A94371460EFD06FDA5237FADE89CE48A9214F244E428E681000D44922C67
3284BB0BC3BE1342CBFA2E6DED15B32E690582CFDA96F7CA93B7288B2491380B
2F4F87646F6BA42240177AB62522E8E26E48E8AF62FD65FB576024A4901042B7
8807A874392E443C9867046F4B020955E1D3C7DA189C2DA86B8BE39AAC8BDDDD
F5625C61972D35EDDD2F639134C7127D866ED4D240E2EA8599E36EBB2F4326CC
FD5BF67E05B20D494FCA2FCB9584ED6F262A67530B2F73EE6B20BF75A115DFD1
245B7C0B9FA978A873E6F7DF8F113E8DA5588F34E4295AF83BA1604D093F92B2
12689E70740F07E94FA2DD0036C9CF0A5CC597BBAA7709AF2B990D03D2325096
03A8237C32CCC91493271F1A3282F7FC211E14511BCF08403F1F7420ACB51B00
96EAB9FDCF06FE0EFF2EB64CCBCD8C28513F230FABEAE1F38D115B1C3AAA7B4F
3526864D3693D68B7842706A856B82845F393A74A07053A72C07B773124A0D6E
D6D80F34263FF374B2DBE0E44DDAAAD96D46986EFA134CA896A249821D3ED59B
84A4D3A75CBD0371ACFFDE8F7F5F1A6377C2B00F9BE4E4AF9C097B44E2DAD57E
7FB05917D16A468F4FCA200933A93EC24A2BE817C3B39133CFF809D577A7C0BC
DD8163842645865C0356D3C75D7CB45669B6CAB61314565222A1493030E61D65
7AE9B1BF34C4CA07A8866B21B9D984325E72EC2A7EFF72E9E7BDABDB4D358E8B
8DDC32EA172A2DE4E8A25320223FD38629B98D35736FD2CCBB0E36AEB6643C28
3A61B6EAC746E61D7F5B5320DB4E6C7F70B76CB486438D247D023157F04EBE73
AEF3E76CF72463FAC5AA7A2799F1C34A459D67F3B6901294A6FA251F64B7353A
6EBFF04C43B3987D73BC69C4A71F63B6B2C6B6FCB93802D72D75FDCBE6E506A2
E8AE0619B1DE7B3CC92D7B44CEFEF8722478F3A1F6D03E8DE7EE3E3328D320D5
137DEA8AF73445F2B3D12501349897584C9FFF833A84A372E4B8E3F22CE2C039
4A4AE1ADBA3C8976ACBAF5037EC11B169B799BB3817F05FB8984BE9BAC739E6E
CBE985067AF19F543D1045FD7E0F586CBF2D1F1811737155EFB5865FD5AAF9B4
83A4DB3B3336216E9251AF461661549339B5958F97E1102E4A18AA45FDD24CC3
A089DA5D3ACAF34D61E6AE01DE3CB1136B41686ABFF068A69EA4BEBD46560DA6
3A449AD07013A724E0E98EF8E8E323092CCA8569A6962C53F493C1EFF24E058C
08F8DF7B6AFFDF2DB49F83EB00406B91F5DD554248300102BE5F322B9DE6F1EE
C974495B5AE2CFB179634E68611C1C54AF6F2D7704B8D39B54D866320877574B
5088B7409783BB808C884F0E073865FF85484E31B39E919155997990278EB396
E7CC0BD7008780FBE633E3B89DA4EF82B28F3DB00C98B7BA7F51762FB1D973D3
948F2D5646DC5515F2632BEBE98A0A13AFEAEBBBA57FC9035A4125C47AB378CA
C921115C92E89F0986783F3E0B08DAFA8F311C3973E40D11EE834BB08319A1A2
3590BE521659F2A9E0A78824F34EA5A6FA55348BF37A4C39F0706B273CCFADC1
4BB25952FB9F925B166103FA5D0695EBF7538738092BC8541D0EB393022F20F5
39EE110A34004817B886A79776907A47591803200CB80B2DFFBCE0C0E5F2D242
B83C46FEA93F0C0A42E8D800A07B67C0809544F5291B20C9B0A19CDA782DA7DA
169A70BF4F987996C4301B147D88C75B1E69BE9B7713866F9F4A3C4A9F02506D
AA3988E60AC0B7456E9409BF1AD68CB7A3EBFB0508A873C54A225F76CFA1DC42
9B4EC1408C7A045F6619096EAB5A3038BA4E404B7D6D184CBA5C4D6E8F8E2C75
D7460CE1BFCD15290A9C3F30A43703968A473CF7B639728CD73D77E86163CD44
A5B455EDDF986EE6AE187AF9282541118EA5A84B6311E4144CDC7AA860C4C12D
BC29B38EB3CE82E8DA1BD259B9919455980A656BDF67E2877BFDF008D5700043
E4D053D3DA1B075E0C8331B59B862B2989BD0E8FED7423A1DC386E8BBCD904E1
6C5E53B5BB923EBEA43ADEE6F7665CF05933D1F8F99696037C5AA7B354A4F1AC
DD12E745BB2FBFF2741AA8FFB82847CF547F29AFAB6C2F2D529DF138ED95C096
5F6EF1B4B9F54FD6F36E40A492A4A06CC6D3429CB2E286B738BE2719E23968D4
59C2CA2E48F1A1A43105912A559D78274189318C9557587C4E6B14AA51BA7362
F9193CEA8BF970E6879DB85A356BA80B9A7B70258F993C87F2C75BD72B5278CF
84E2A886676A91C41966D6890030A695F24FB13CB7D83968F06D05F5A26B783A
FA95962E9438FC3B10239FC8BE7809F10D5F9288C410487290808B88F9421D50
6386AC95C519D9D83BD9B3617334857EA92C2DB592CF08B3DE2FFCE6B9F611F8
88480312792A775F2F6E42D82C460F5522FF52A7FF124E3C90EC49059AF265FC
CC9ACB88D1A17882EC0CE0D8542F775920C658A959215C7F1003E5B41D29BDAC
3D8C274AA862B9369441EDBAF6726A730538926203A9770950858BE19002D253
E44AE117F6277FFD97E3734D18DFD9C56658965231411F110FCC1ED63C1CC0F0
317260EEBDB06B8C68AA4FF461BB6D1296A5A8B2516DF6F88D4AE8A2F23BD06E
CB8B0516A6F95F40966FCA2B046C41B5B2AD6BE04FA169800228BAE3E6D4040A
1FB1E65397A39E769DF23C1D07FB9A61DDB92EC67EC42BBA4776A5067970D227
34B027285AFF2C77E0E26F3A52D24EFAE296405CA92AB1E898987F8990C6858F
1F6817232543F9AF30ECEF0D86125D70BCB7A92B2BE3AF10DE38F0D4C7CCD931
4923F532E28EDC1F4EC3D0E698D823569BE431A9B3E3471C609BFFD6A27A9635
1DC61E31A84052026BCD278CA322575D75103851939F8F9C31AD68B85E70AACC
410555B525925D9BEED7A3B4294B006D7B9228DE57B91032986423BE1A589D2E
D43BA77A225D18E01A24E9AD6B9F764E268D0F02C88423F82D718BC9D7993478
A0CBACF68B846FEA8F760EBFCCF49C7D65C9DC6709B206DD0229A2B37F520136
C4E3D2C9EADBE885AB88C849686F7A74D985BEC536E96633BEA4CBC1B060F2DD
41D985D552F7E5DC23352FD902BF6F5B5CCC85FE8ADB7671966D5E1909ACBFEB
342BF961147137F29D0457F7E9DDBA2549852043B5A93B8C7DA6D16F64C3CF84
D271D12722ECAEBA773E594003499F0F90FD53C30FDFAE67E8B8632CD872B158
F05CA09E4034188789CC71EC7DE9891AD5B85ABC26CB4087A7814F5D6AE5AF1B
761D55F04D2AAD7D1332C408C18C647FBC4AB1C1818AFE7FD63870B38E4100D6
7ACF9EB4C072D3196F99FC351092592AD968CB3E74C7CE0C692A00E53F59B1F5
2994A7A5C561D30A7CA2F279276A63DC4E3609777A97D166E42D409B8EF2646C
679180A36895C301399D1EFEF99955886C444F83365CE41BF7BDA5157CBAAB3D
EA2A697F4A8BD9635311108D162F9B7210012EA351D72974D64CF20AF491CE10
C53D272ECDEC1C574EE6893B67851AD5896ACA01B2989993D432EE93A75860E5
0D0896B358F252BB5005EE6F47DE5D892813AF0BA074FBAB82466532AF71DBDA
671CCABE69652A7A0E48CD62CEC99426A4FC31C9828CF2AC80B73CE2768B0654
5FE2641054B78BEB3E44B78C50316C61B6FE484CE582EB7FB72DD8A3A2A4D87F
C5875FCA2059C93DF06A84B1D55E39CEE39654E76C73BFC3C79DD8311101317A
71126DA51CBE68C1D39A78B96EF9DF60D8ACAD2BD90CF4641D3A1FA1EF5E294C
0DC2B645CD0FB207639CA85E0B9CBB39B01660BCBDC41758B4122E88E548D22E
15A2087B61FD6AA6984F007A8EE703F49874F401C2C2DA8C44148B894518EEDB
602A670CA6E94C8BCCF83DB0AC7B39632F0D4531C3569E58941EC067EC4C03A2
F8D4D19690C2AFC60DDFBBE52C2A97EFB0D86DD9BF2F3AB34DE24D16AF015B0E
A63F83FAC01F1A052E23200E94DCDA8807FC3021A529C4C8E5E7588DF0FF94DD
8F130158933F88571D558B760B1E2F1B972B143DA98F5CF93DB14805DB66731C
E5C750915AE1A7B21172D02E3D78E253519DC09411034B237E51A2583CC1F6D4
C1D2E5EA316A091C458AD3966289EE36DBD3B89455CA9BFE2FE8ED26203A2B35
3C3C9C7D08B9EA544860D688E9CDF25E98769FDA84FA98DAA55B5E8CA090E60C
409D96FCFA4637EE0055EB8288CCBA72B4C23F182C0A05FFFED46A724C32E034
BA918AAFCCA9D3BB807F7B8540B5D1D958D02216A81D7104C0A1ED8AD2691762
8D054CC45D6FBA0817F6A00C24D68A3F2413C00A31302E342C5DE54303E52D09
56E6D188EDB2C1005327079D5A67E1ED6308F30998D4C5AABC3927A8D41BD5C4
3A05C2ECE7893D4F709ABD9FB5301E71F20C284307E54829FA4E36B920B99082
1F8D80AAC1B3E20F48B33BF9CB313CF0CD29AC91D24F13EDA9F998ECA664F9A8
BD9CC813A7391ECD72062BBDBA4BF29F957B8615A48E02B3FC5B49F82B4F5637
97E65448E4FD96656450D5D43C08932DAFEFB61E441B8F86288B7981A56DDC19
2CC6433182A2E2A108FE694A8C7A1F0AEBAA6D4B38ADE6776E8508F0ADF02DA2
A3F43E2F2C3D0D4AC2A4D0FD15EFFA4F02B8D14EBB1479F53AD305ED895109EC
56C018675C92469A0662335A2DB9C80E2877C20F30B91F3F0590BD7DD9DA3723
811B05C5E9FA75E0ED1AC1A0B2F8AE8E295F2BF7FB992F27A161C0E90F6C7BDC
C08621BF3FF447BC183C64A8B5AFC1716F9E5D0B8DBD1C9FA7A4103BEECDA663
D6B631992542F92694ACE072713FBB863240DD0344AD522C87531CFCCA544E8F
FA3F82954DD8527AE007A1A445DFD7BB1D6D0AF0D245010C397EFC9A23B8BB4A
46413DFF99A7F0916B32CDC3172AEF832B77F1B25658014BFDFAF6006B977FDB
5313DAFAB8930CDAA1283F1CB245F5443FABE20F45296FA9DE7017E57C2C582E
37B2EF5E7BEC52AA6DAAAC5BE195345F5D4BF855AB704259E600D6563B6F60F4
C52ED1A09BF21A730C1C63D46D7FECDA633259CD486C11A5AF8CD69E25CB2C0B
B3B05CC25CF0D73A7BD9198D2E4C72E3EF7656F1FCFD588F38DD12080D7BBABC
C5FB38BBF0CFEE5DE8F2C81A7EB290A84F50F5A2613C0DCBAF267EE06D621BC3
6035A78E8051C3E1C8D1C122D17CC69CB088587F8F5024AAD110BCBFEE6A59B9
B32EBFC9F63F32435512CADA05EC571BACACE9F787864095538BDB7E5053B071
31683DC360DF06487AAAE89C786302CF1843D25E266CBA8B59405F05BFFA2E3E
704E6A34C8F6750EF1819B932B0E97DF36E8038613A1D764454FB49249E1DF72
3DD65266C362517FD5C9FD29ED01C6210B0A8620475125E78C2239BD6BCE8FA8
8970407A9F12E7377454F28344109D453A8CD3EC646515EB8FEF55DB4CDBA32A
B4BB96C9AD97511BF644A65483A226F64C86A1D8B38514AC894FFC698D4DA2DB
34C62A4B77EAE2777364DF9F1E66ACCFD246925508AE35CB8763834B3D8E4D7A
CA5875B917AF3DE07D18087620937F605EB52F0425C1A4F2AD6C6265C149C5FD
8498C635D45F966CBF89219CFDAF0263472569E90F66775A2E1EE8BB1E271715
90B8A3ED1A1C94987E23527353E9D5F2E73E6B1CB2668D9259689EC89A8A6C91
65F3C50674B88ED3F02077052957195BBDD34F618CF38CE5EB0983B2038449CB
F75C32BCCC6894608678D54C43B474628293516D1FF391B1770C5C3BD4E35FEC
ED9B0651A8A701DB1D98199042D21F9395510B9B0E2FADA12936D4890C0E99F3
EC088FEBD55A72AA45D6134609A1958B1C297DB82A1C621B5EF6B20F0F11FF28
010A00C01BB9739404A6F2158F767AB48396AC10319950D3CCA5F9FA2B6FD2B5
2737E98DA5DACBC821748214E23359DC64E72D
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258437 52099154 1000 600 600 (splash.dvi)
@start /Fa 136[55 37 1[23 32 32 1[42 42 42 60 23 2[23
1[42 23 37 1[37 1[42 14[51 82[{ TeXBase1Encoding ReEncodeFont }17
83.022 /NimbusRomNo9L-ReguItal rf /Fb 134[42 3[42 23
32 1[42 1[42 42 1[23 2[23 42 42 1[37 1[37 14[51 7[51
4[60 3[55 22[21 44[{ TeXBase1Encoding ReEncodeFont }18
83.022 /NimbusRomNo9L-Regu rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 0 TeXcolorgray Black 515 440 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def

515 440 a 515 440 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 515 440 a 515 440 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 515 440 a 0 TeXcolorgray
728 1668 a
tx@Dict begin { 0.0 0.0 } PutCoor PutBegin  end
 728 1668 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 0  setgray   0. true -7.22743 46.97505 242.10493 144.54 .5
Frame  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
728 1668 a
tx@Dict begin  PutEnd  end
 728 1668 a 728 1668 a
tx@Dict begin { 0.0 83.11005 } PutCoor PutBegin  end
 728 1668 a @beginspecial
0 @llx 0 @lly 504 @urx 288 @ury 540 @rhi @setspecial
%%BeginDocument: gfx/GT-cbrd.eps
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 0 0 504 288
%%Creator: Gisselquist Technology LLC
%%Title: Gisselquist Technology Logo
%%CreationDate: 11 Mar 2014
%%EndComments
%%BeginProlog
/black { 0 setgray } def
/white { 1 setgray } def
/height { 288 } def
/lw { height 8 div } def
%%EndProlog
% %%Page: 1

false { % A bounding box
	0 setlinewidth
	newpath
	0 0 moveto
	0 height lineto
	1.625 height mul lw add 0 rlineto
	0 height neg rlineto
	closepath stroke
} if

true { % The "G"
	newpath
		height 2 div 1.25 mul height moveto
		height 2 div height 4 div sub height lineto
		0 height 3 4 div mul lineto
		0 height 4 div lineto
		height 4 div 0 lineto
		height 3 4 div mul 0 lineto
		height height 4 div lineto
		height height 2 div lineto
		%
		height lw sub height 2 div lineto
		height lw sub height 4 div lw 2 div add lineto
		height 3 4 div mul lw 2 div sub lw lineto
		height 4 div lw 2 div add lw lineto
		lw height 4 div lw 2 div add lineto
		lw height 3 4 div mul lw 2 div sub lineto
		height 4 div lw 2 div add height lw sub lineto
		height 2 div 1.25 mul height lw sub lineto
			closepath fill
	newpath
		height 2 div height 2 div moveto
		height 2 div 0 rlineto
		0 height 2 div neg rlineto
		lw neg 0 rlineto
		0 height 2 div lw sub rlineto
		height 2 div height 2 div lw sub lineto
	closepath fill
} if

height 2 div 1.25 mul lw add 0 translate
false {
	newpath
		0 height moveto
		height 0 rlineto
		0 lw neg rlineto
		height lw sub 2 div neg 0 rlineto
		0 height lw sub neg rlineto
		lw neg 0 rlineto
		0 height lw sub rlineto
		height lw sub 2 div neg 0 rlineto
		0 lw rlineto
	closepath fill
} if

true {
	newpath
		0 height moveto
		height lw add 2 div 0 rlineto
		0 height neg rlineto
		lw neg 0 rlineto
		0 height lw sub rlineto
		height lw sub 2 div neg 0 rlineto
	closepath fill

	newpath
		% (height + lw)/2 + lw
		height lw add 2 div lw add height moveto
		% height - (above) = height - height/2 - 3/2 lw = height/2-3/2lw
		height 3 lw mul sub 2 div 0 rlineto
		0 lw neg rlineto
		height 3 lw mul sub 2 div neg 0 rlineto
		closepath fill
} if


grestore
showpage
%%EOF

%%EndDocument
 @endspecial 728 1668 a
tx@Dict begin  PutEnd  end
 728 1668 a 728 1668 a
tx@Dict begin { 79.49744 79.49744 } PutCoor PutBegin  end
 728 1668
a 728 1549 a
 currentpoint currentpoint translate 1.8 1.8 scale neg exch neg exch
translate
 728 1549 a -51 x Fb(Gisselquist)728 1597
y(T)-6 b(echnology)h(,)16 b(LLC)728 1549 y
 currentpoint currentpoint translate 1 1.8 div 1 1.8 div scale neg
exch neg exch translate
 728 1549 a
728 1668 a
tx@Dict begin  PutEnd  end
 728 1668 a 728 1668 a
tx@Dict begin { -3.61371 43.36243 } PutCoor PutBegin  end
 728 1668 a 728 1668
a
tx@Dict begin { 93.89418 28.45274 } PutCoor PutBegin  end
 728 1668 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 2.168 SLW 0 0 0.7  setrgbcolor  /ArrowA { moveto } def /ArrowB { }
def    /x -0.92 def /x1 5.05 def /dx x1 x sub 599 div def /F@pstplot
{  dup 70 sub 1.2 div dup 0 lt { pop 0 } { dup 30 lt { dup 2 mul 3.14159
mul sin dup mul exch 2 mul 3.14159 mul 8 mul cos mul } { 0 mul } ifelse
} ifelse 0.25 neg mul 0.1 add  } def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  599 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 2.168 SLW 0 0 0.7  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 728
1668 a
tx@Dict begin  PutEnd  end
 728 1668 a 728 1668 a
tx@Dict begin  PutEnd  end
 728 1668 a 728 1668 a
tx@Dict begin { 123.29216 57.81621 } PutCoor PutBegin  end
 728
1668 a -169 1688 a Fa(Rein)m(venting)i(signal)h(pr)l(ocessing)h(one)g
(waveform)g(at)g(a)g(time)728 1668 y
tx@Dict begin  PutEnd  end
 728 1668 a 639 443
2127 4 v 639 1305 4 864 v 2762 1305 V 639 1307 2127 4
v 0 TeXcolorgray 0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
